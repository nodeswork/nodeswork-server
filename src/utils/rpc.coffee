_         = require 'underscore'
LRU       = require 'lru-cache'

{logger}  = require '@nodeswork/logger'


# A Rpc object used to call remote functions.
class Rpc

  constructor: ({@socket}) ->


# @nodoc
defaultSocketKey = _.property 'id'


# Act as a rpc caller.
class RpcCaller

  # Construct a new RpcCaller.
  #
  # @option options [Number] timeout=0 specifies how long the request to be
  #   cleared. 0 means no timeout.
  # @option options [Number] bufferSize=100 specifies how large is the buffer.
  #   Responses could be missing if the buffer size is too small.
  # @option options [Array<String>] funcs=[] specifies the names of the
  #   functions.
  # @option options [Function] socketKey retrieve the key of the socket, used to
  #   get back the Rpc instance. Default is socket.id.
  constructor: (options) ->
    {
      @timeout     = 0
      @bufferSize  = 100
      @funcs       = []
      @socketKey   = defaultSocketKey
    }           = options
    @_callstack = LRU {
      max:     @bufferSize
      maxAge:  1000 * 60 * 60    # 60 minutes
    }
    @_sid       = 0

    # @nodoc
    class RpcClass extends Rpc
    @_RpcClass  = RpcClass

    @_rpcs      = {}
    that        = @
    _.each @funcs, (func) =>
      @_RpcClass::[func] = (params...) ->
        that.sendRequest @socket, name: func, params: params

  # Send request to the remote.
  #
  # @param [Socket, Key] socket specifies which socket to call.
  # @option options [String] name required, specifies the name of the calling
  #   function.
  # @option options [Array] params specifies the parameters.
  sendRequest: (socket, options) ->
    request = {
      name:    options.name
      params:  options.params
      sid:     @_sid++
    }

    logger.info 'Send a rpc call', request
    socket.emit 'rpc::call', request

    new Promise (resolve, reject) =>
      @_callstack.set request.sid, [resolve, reject]

      if @timeout
        setTimeout (() =>
          if @_callstack.has request.sid
            @_callstack.del request.sid
            reject "Timeout."
        ), @timeout

  # Register new socket.
  #
  # @param [Socket] socket the socket to be registered.
  # @return [Rpc] the registered rpc.
  registerSocket: (socket) ->
    key         = @toKey socket
    logger.info 'Register a new socket:', {key}

    socket.on 'rpc::response', (resp) =>
      logger.info 'Receieve rpc response:', resp
      if @_callstack.has resp.sid
        [resolve, reject] = @_callstack.get resp.sid
        if resp.status == 'ok' then resolve resp.data
        else reject resp.error
        @_callstack.del resp.sid
      else
        logger.warn 'The rpc entry is gone:', sid: resp.sid

    # TODO: without checking existing rpc may cause memory leak.
    # throw new Error("Socket has already been registerd.") if @_rpcs[key]?
    @_rpcs[key]  = new @_RpcClass socket: socket

  # Unregister the existing socket.
  #
  # @param [Socket, Key] socket the socket to be unrequestered.
  unregisterSocket: (socket) ->
    key    = @toKey socket
    delete @_rpcs[key]
    return

  # Retrieve registered socket by the key.
  #
  # @param [String, Socket] key
  # @return [Rpc] rpc
  rpc: (key) ->
    @_rpcs[@toKey key]

  # Convert key or socket to socket.
  #
  # @param [Socket, Key] key generated by socketKey function.
  # @return [Socket] socket
  toSocket: (key) ->
    if _.isString key then @_rpcs[key].socket
    else key

  # Convert key or socket to key.
  #
  # @param [Socket, Key] socket socket or key.
  # @return [String] key
  toKey: (socket) ->
    if _.isString socket then socket
    else @socketKey socket


module.exports = {
  Rpc
  RpcCaller
}
